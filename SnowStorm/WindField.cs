using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Drawing;

namespace SnowStorm
{
    /// <summary>
    /// A field of wind vectors, these vectors take up a given space and can adjust the
    /// speed of objects.  This field has a resolution that can be used to save on space
    /// and prevent objects from having really jerky movements.
    /// </summary>
    class WindField
    {
        /// <summary>
        /// Flag that expresses the dimension of the matrix that is the column.
        /// </summary>
        private const int COLUMN_DIMENSION = 1;
        /// <summary>
        /// Flag that expresses the dimension of the matrix that is the row.
        /// </summary>
        private const int ROW_DIMENSION = 0;

        /// <summary>
        /// Maximum force in the X direction for the wind speed.
        /// </summary>
        private const float VECTOR_X_RANGE = 15;
        /// <summary>
        /// Maximum falling speed of a SnowFlake.
        /// </summary>
        private const float VECTOR_Y_RANGE = 14;

        /// <summary>
        /// Field of vectors that represents the directions in this field.
        /// </summary>
        public Vector[,] field;
        /// <summary>
        /// How many onscreen pixels each field value represents.
        /// </summary>
        private Size fieldResolution;
        /// <summary>
        /// General direction of the wind blowing, applied on top of the field
        /// </summary>
        private Vector generalWind;

        /// <summary>
        /// Creates a new vector field of the given width and heighth, to the nearest acceptable
        /// measure based on the given resolution.
        /// </summary>
        /// <param name="width">Width of the field.</param>
        /// <param name="height">Height of the field.</param>
        /// <param name="generalDirection">General direction of the wind force generated by this field.</param>
        /// <param name="fieldResolution">
        /// Resolution of the field.  This is how many pixel units
        /// on the field are taken up by a single vector.
        /// </param>
        public WindField(int width, int height, Vector generalDirection, Size fieldResolution)
        {
            field = new Vector[(height + fieldResolution.Height - 1) / fieldResolution.Height,
                               (width + fieldResolution.Width - 1) / fieldResolution.Width];

            this.fieldResolution = fieldResolution;

            this.generalWind = generalDirection;

            this.SetFieldVariation( );
        }

        /// <summary>
        /// Creates a new vector field of the given width and heighth, to the nearest acceptable
        /// measure based on the given resolution.
        /// </summary>
        /// <param name="width">Width of the field.</param>
        /// <param name="height">Height of the field.</param>
        /// <param name="generalDirection">General direction of the wind force generated by this field.</param>
        /// <param name="variance">How much the field can vary from the general direction.</param>
        /// <param name="fieldResolution">
        /// Resolution of the field.  This is how many pixel units
        /// on the field are taken up by a single vector.
        /// </param>
        public WindField(int width, int height, Vector generalDirection, Vector variance, Size fieldResolution)
        {
            field = new Vector[(height + fieldResolution.Height - 1) / fieldResolution.Height,
                               (width + fieldResolution.Width - 1) / fieldResolution.Width];

            this.fieldResolution = fieldResolution;

            this.generalWind = generalDirection;

            this.SetFieldVariation( generalDirection, variance);
        }

         /// <summary>
        /// Randomize the vectors in the field, and average them out to get a smoother continuim.
        /// <param name="generalDirection">General direction that the vectors should point.</param>
        /// <param name="variance">How much the vectors can vary from the general direction.</param>
        /// </summary>
        private void SetFieldVariation(Vector generalDirection, Vector variance)
        { 
            // Max number of columns and fields
            int fieldColumns = field.GetLength(COLUMN_DIMENSION);
            int fieldRows = field.GetLength(ROW_DIMENSION);

            Vector[,] randomVectors = new Vector[fieldRows, fieldColumns];

            // Fill the array with random vectors
            for(int i = 0; i < fieldRows; i++)
                for( int j = 0; j < fieldColumns; j++ )
                {
                    randomVectors[i, j] = new Vector( Random.Float(-variance.x, variance.x),
                                                      Random.Float(-variance.y, variance.y) );
                    randomVectors[i, j].Add( generalDirection );
                }

            // Average each vector over a range of random vectors
            for( int i = 0; i < fieldRows; i++ )
                for( int j = 0; j < fieldColumns; j++ )
                    AverageVectorWithNeighbors( randomVectors, i, j );
        }

        /// <summary>
        /// Randomize the vectors in the field, and average them out to get a smoother continuim.
        /// </summary>
        private void SetFieldVariation()
        { 
            // Max number of columns and fields
            int fieldColumns = field.GetLength(COLUMN_DIMENSION);
            int fieldRows = field.GetLength(ROW_DIMENSION);

            Vector[,] randomVectors = new Vector[fieldRows, fieldColumns];

            // Fill the array with random vectors
            for(int i = 0; i < fieldRows; i++)
                for( int j = 0; j < fieldColumns; j++ )
                {
                    randomVectors[i, j] = new Vector( Random.Float(-VECTOR_X_RANGE, VECTOR_X_RANGE),
                                                      Random.Float(-VECTOR_Y_RANGE + 1, VECTOR_Y_RANGE) );
                }

            // Average each vector over a range of random vectors
            for( int i = 0; i < fieldRows; i++ )
                for( int j = 0; j < fieldColumns; j++ )
                    AverageVectorWithNeighbors( randomVectors, i, j );
        }

        /// <summary>
        /// Averages a vector with itself and it's neighbors.  Sets the field values.
        /// </summary>
        /// <param name="randomVectors">Random field of vectors to use to make averages.  Shouldn't be the field.</param>
        /// <param name="i">Column of vector to set.</param>
        /// <param name="j">Row of vector set.</param>
        private void AverageVectorWithNeighbors(Vector[,] randomVectors, int i, int j)
        { 
            const int VECTOR_AVERAGE_RANGE = 1;     // Range of adjacent row or column to sweep through
            float xSum, ySum;                       // Sum of non empty adjacent vector values
            float numVectors;                       // Number of adjacent non-empty vectors
            int rowStart, rowEnd, columnStart, columnEnd;         // Range to average the vector values through

            // Set the bounds of vectors to average.
            rowStart = i - VECTOR_AVERAGE_RANGE;
            rowEnd = i +  VECTOR_AVERAGE_RANGE;
            columnStart = j - VECTOR_AVERAGE_RANGE;
            columnEnd = j + VECTOR_AVERAGE_RANGE;

            // Intersect average bounds with the randomVectors field
            if( rowStart < 0 )
                rowStart = 0;
            if( rowEnd >= randomVectors.GetLength( ROW_DIMENSION ) )
                rowEnd = randomVectors.GetLength( ROW_DIMENSION ) - 1;

            if( columnStart < 0 )
                columnStart = 0;
            if( columnEnd >= randomVectors.GetLength( COLUMN_DIMENSION ) )
                columnEnd = randomVectors.GetLength( COLUMN_DIMENSION ) - 1;

            // No vectors summed yet
            xSum = 0;
            ySum = 0;
            numVectors = 0;

            for(int row = rowStart; row <= rowEnd; row++)
                for( int column = columnStart; column <= columnEnd; column++ )
                {
                    xSum += randomVectors[row, column].x;
                    ySum += randomVectors[row, column].y;
                    numVectors++;
                }

            // Get the average of the vectors
            xSum /= (short)numVectors;
            ySum /= (short)numVectors;

            // Make directionless vectors point one down
            if( Math.Abs( ySum ) + Math.Abs( xSum ) <= 0 )
                ySum = 1;

            // Set the vector
            field[i, j] = new Vector( xSum, ySum );
        }

        /// <summary>
        /// Sets the direction to be the same as the location represented in this WindField.
        /// </summary>
        /// <param name="location">Location of the item to affect by the wind</param>
        /// <param name="direction">Direction of the item to set based off the wind.</param>
        public void SetVector(Vector location, ref Vector direction)
        { 
            // Offset to hash into the field
            int column = ( int )location.x / fieldResolution.Width;
            int row = ( int )location.y / fieldResolution.Height;

            // Make sure the index maps to the field
            if( row < 0 || row > field.GetLength( ROW_DIMENSION ) ||
                column < 0 || column > field.GetLength( COLUMN_DIMENSION ) )
            {
                throw new IndexOutOfRangeException( );
            }

            direction = field[row, column];
            

            // Make it so that the wind always falls to the ground
            if( direction.y <= .5f )
                direction.y = .5f;
        }

        /// <summary>
        /// Gets an image of the WindField that describes the field.
        /// Mainly for testing purposes.
        /// </summary>
        /// <returns>A visual representation of the wind field.</returns>
        public Bitmap GetFieldAsImage()
        {
            Bitmap fieldImage = new Bitmap( field.GetLength( COLUMN_DIMENSION ) * fieldResolution.Width,
                                           field.GetLength( ROW_DIMENSION ) * fieldResolution.Height );

            Graphics g = Graphics.FromImage( fieldImage );

            // Draw the fields area for each vector value
            int x1, y1, x2, y2;
            float angle;

            int halfWidth = fieldResolution.Width / 2;
            int halfHeight = fieldResolution.Height / 2;

            for(int i = 0; i < field.GetLength(ROW_DIMENSION); i++)
                for( int j = 0; j < field.GetLength( COLUMN_DIMENSION ); j++ )
                {
                    Vector v = field[i, j];
                    angle = v.Angle * 180f / (float)Math.PI;

                    x1 = j * fieldResolution.Width;
                    y1 = i * fieldResolution.Height;
                    x2 = fieldResolution.Height;
                    y2 = fieldResolution.Width;
                    Rectangle box = new Rectangle(x1, y1, x2, y2);


                    
                    int magnitude = (int)v.Magnitude;

                    x1 += halfWidth - magnitude;
                    y1 += halfHeight - magnitude;
                    x2 -= halfWidth * 2 - magnitude * 2;
                    y2 -= halfHeight * 2 - magnitude * 2;

                    Rectangle box2 = new Rectangle(x1, y1, x2, y2);






                    g.FillRectangle(Brushes.Black, box);
                    g.DrawRectangle( Pens.White, box );

                    g.FillEllipse( Brushes.Red, box2 );
                    g.DrawPie(Pens.White, box, angle, 360);

                }
                 
            // Draw the line representing each vector value
            for(int i = 0; i < field.GetLength(ROW_DIMENSION); i++)
                for( int j = 0; j < field.GetLength( COLUMN_DIMENSION ); j++ )
                {
                    //Vector v = field[i, j];
                    //angle = v.Angle;
                    //int halfWidth = fieldResolution.Width / 2;
                    //int halfHeight = fieldResolution.Height / 2;
                    

                    //x1 = j * fieldResolution.Width + halfWidth;
                    //y1 = i * fieldResolution.Height + halfHeight;
                    ////x2 = x1 + v.x;
                    ////y2 = y1 + v.y;
                    //x2 = x1 + (int)(Math.Cos(angle) * halfWidth);
                    //y2 = y1 + (int)(Math.Sin(angle) * halfHeight);

                    //g.DrawLine( Pens.White, x1, y1, x2, y2);
                    //g.DrawPie(Pens.Black
                }

            return fieldImage;
        }
    }
}
